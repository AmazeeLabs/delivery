<?php

/**
 * @file
 * Drupal hooks and helper functions.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Url;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\ContentEntityTypeInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityFormInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\delivery\WorkspaceListBuilder;
use Drupal\workspaces\Entity\Workspace;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_entity_view_mode_info_alter().
 */
function delivery_entity_view_mode_info_alter(&$view_modes) {

}

/**
 * Implements hook_entity_type_build().
 */
function delivery_entity_type_build(array &$entity_types) {
  // Override the list builder so we can inject our own deploy button.
  $entity_types['workspace']->setHandlerClass('list_builder', WorkspaceListBuilder::class);

  // Introduce a new "merge" form for each revisionable entity type.
  // Content moderation will take over 'edit' and 'default' forms. That is the
  // cleanest way to create merge revisions without getting in its way.
  foreach ($entity_types as $entityType) {
    if (
      $entityType instanceof ContentEntityTypeInterface &&
      $entityType->isRevisionable() &&
      !$entityType->isInternal()
    ) {
      $constraints = $entityType->getConstraints();
      unset($constraints['EntityUntranslatableFields']);
      $entityType->setConstraints($constraints);
      $entityType->setFormClass('merge', $entityType->getFormClass('edit'));
    }
  }
}

/**
 * Implements hook_entity_operation_alter().
 */
function delivery_entity_operation_alter(array &$operations, EntityInterface $entity) {
  if (!$entity instanceof Workspace) {
    return;
  }
  if (empty($operations['deploy'])) {
    return;
  }

  $userWorkspaces = \Drupal::service('delivery.service')->getUserWorkspaces(\Drupal::currentUser());

  if ((\Drupal::currentUser()->hasPermission('add delivery to assigned workspaces') &&
      in_array($entity->id(), $userWorkspaces)) ||
      \Drupal::currentUser()->hasPermission('add delivery to any workspaces')) {
    // Add a deliver content link.
    $operations['deliver'] = [
      'title' => t('Deliver content'),
      'weight' => 0,
      'url' => Url::fromRoute('delivery.workspace_delivery_controller', ['workspace' => $entity->id()]),
    ];
  }
  unset($operations['deploy']);
}

/**
 * Implements hook_ENTITY_TYPE_view_alter() for deliveries.
 */
function delivery_delivery_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  $build['items'] = views_embed_view(
    'delivery_status',
    'embed',
    $entity->id()
  );
}

/**
 * Implements template_preprocess_menu_local_action().
 */
function delivery_preprocess_menu_local_action(&$variables) {
  _delivery_preprocess_forward_action_link($variables);
  _delivery_preprocess_pull_action_link($variables);
}

/**
 * Set the visibility of the delivery forward action link.
 *
 * @param $variables
 */
function _delivery_preprocess_forward_action_link(&$variables) {
  // Disable the forward delivery button if necessary.
  $route_match = \Drupal::routeMatch();
  if ($route_match->getRouteName() != 'entity.delivery.canonical') {
    return;
  }
  if (empty($variables['link']['#url'])) {
    return;
  }
  if (!$variables['link']['#url'] instanceof Url) {
    return;
  }
  if (!$delivery = $route_match->getParameter('delivery')) {
    return;
  }
  if ($variables['link']['#url']->getRouteName() != 'delivery.delivery_forward') {
    return;
  }

  /**
   * This has to be set to 0 so we can dynamically check the forwarding status.
   *
   * @todo find a better way of doing this - could be solved by DAI-364.
   */
  return;
  $variables['#cache'] = ['max-age' => 0];
  $delivery_service = \Drupal::service('delivery.service');
  if ($delivery_service->canForwardDelivery($delivery)) {
    return;
  }
  $variables['link']['#options']['attributes']['class'][] = 'ui-state-disabled';
}

/**
 * Set the visibility of the delivery pull action link.
 *
 * @param $variables
 */
function _delivery_preprocess_pull_action_link(&$variables) {
  // Disable the forward delivery button if necessary.
  $route_match = \Drupal::routeMatch();
  if ($route_match->getRouteName() != 'entity.delivery.canonical') {
    return;
  }
  if (empty($variables['link']['#url'])) {
    return;
  }
  if (!$variables['link']['#url'] instanceof Url) {
    return;
  }
  if (!$delivery = $route_match->getParameter('delivery')) {
    return;
  }
  if ($variables['link']['#url']->getRouteName() != 'delivery.delivery_pull') {
    return;
  }

  /**
   * This has to be set to 0 so we can dynamically check the forwarding status.
   *
   * @todo find a better way of doing this - could be solved by DAI-364.
   */
  return;
  $variables['#cache'] = ['max-age' => 0];
  $delivery_service = \Drupal::service('delivery.service');
  if ($delivery_service->canPullDelivery($delivery)) {
    return;
  }
  $variables['link']['#options']['attributes']['class'][] = 'ui-state-disabled';
}

/**
 * Implements hook_preprocess_views_view().
 */
function delivery_preprocess_views_view(&$variables) {
  if ($variables['id'] == 'deliveries') {
    $variables['#attached']['library'][] = 'delivery/entity-status';
    $variables['#attached']['library'][] = 'delivery/entity-status-callback';
  }
}

/**
 * Implements hook_entity_insert().
 *
 * If a workspace enabled entity is created, immediately create a local revision
 * in the current workspace. Required for the conflict resolution mechanism to
 * work properly.
 */
function delivery_entity_insert(EntityInterface $entity) {
  /** @var \Drupal\workspaces\WorkspaceManagerInterface $workspaceManager */
  $workspaceManager = \Drupal::service('workspaces.manager');
  $currentWorkspace = $workspaceManager->getActiveWorkspace();
  if ($currentWorkspace->id() !== 'live' && $workspaceManager->isEntityTypeSupported($entity->getEntityType())) {
    /** @var \Drupal\Core\Entity\ContentEntityStorageInterface $storage */
    $storage = \Drupal::service('entity_type.manager')->getStorage($entity->getEntityTypeId());
    $revision = $storage->createRevision($entity);
    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
    $revision->revision_parent->target_id = $entity->getRevisionId();
    $revision->save();
  }

  _delivery_update_entity_index($entity);
}

/**
 * Implements hook_entity_update().
 */
function delivery_entity_update(EntityInterface $entity) {
  _delivery_update_entity_index($entity);
}

/**
 * Implements hook_form_alter().
 */
function delivery_form_alter(&$form, FormStateInterface $formState, $formId) {
  // Ensure the revision revert confirmation form works in all workspaces.
  $formState->set('workspace_safe', TRUE);
  $formObject = $formState->getFormObject();

  // Don't allow to change the language on existing entities.
  if (
    $formObject instanceof EntityFormInterface &&
    $formObject->getEntity() instanceof ContentEntityInterface &&
    $formObject->getEntity()->isTranslatable() &&
    array_key_exists('langcode', $form)
  ) {
    $form['langcode']['#access'] = $formObject->getEntity()->isNew();
    if ($formObject->getEntity()->isNew()) {
      /** @var \Drupal\workspaces\WorkspaceManagerInterface $workspaceManager */
      $workspaceManager = \Drupal::service('workspaces.manager');
      $workspace = $workspaceManager->getActiveWorkspace();
      if ($defaultLanguage = $workspace->primary_language->value) {
        $form['langcode']['widget'][0]['value']['#default_value'] = $defaultLanguage;
      }
    }
  }

  if ($formObject instanceof EntityFormInterface && $formObject->getOperation() === 'merge') {
    // Run 'merge' forms through the inline conflict resolution form builder.
    \Drupal::service('conflict.resolution_inline_form.builder')->processForm($form, $formState, $formObject->getEntity());
    // Kill the message popup added by the inline conflict ui.
    // TODO: Properly separate this in the conflict module.
    unset($form['#attached']['drupalSettings']['conflict']);
    if (isset($form['body']['conflict_resolution'])) {
      // Hide the conflict resolution info for body fields.
      // TODO: Handle this with per field conflict widgets instead.
      unset($form['body']['conflict_resolution']);
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function delivery_module_implements_alter(&$implementations, $hook) {
  // Remove conflict module's form and entity alteration. We never want conflicts
  // in a standard entity form but only in our dedicated "merge" form mode.
  if (in_array($hook, ['form_alter', 'entity_load'])) {
    unset($implementations['conflict']);
  }

  if (in_array($hook, ['entity_bundle_info_alter', 'entity_base_field_info_alter'])) {
    $group = $implementations['delivery'];
    unset($implementations['delivery']);
    $implementations['delivery'] = $group;
  }
}

/**
 * Update revision_tree index.
 */
function _delivery_update_entity_index($entity) {
  $workspace_manager = \Drupal::service('workspaces.manager');
  if ($workspace_manager->isEntityTypeSupported($entity->getEntityType()) && $entity->getLoadedRevisionId() != $entity->getRevisionId()) {
    \Drupal::service('delivery.revision_index')->updateIndex([$entity->id()], $entity->getEntityType()->id());
    \Drupal::service('delivery.revision_index')->updateIndex([$entity->id()], $entity->getEntityType()->id(), TRUE);
  }

  // We have to update index for workspace in case of parent change or creation.
  if ($entity->getEntityType()->id() == 'workspace') {
    if (empty($entity->original) ||
      ($entity->parent_workspace->target_id !== $entity->original->parent_workspace->target_id)) {
      $entityTypeManager = \Drupal::service('entity_type.manager');

      foreach ($entityTypeManager->getDefinitions() as $entity_type_id => $entity_type) {
        if ($workspace_manager->isEntityTypeSupported($entity_type)) {
          \Drupal::service('delivery.revision_index')->updateIndex([], $entity_type_id, FALSE, $entity->id());
          \Drupal::service('delivery.revision_index')->updateIndex([], $entity_type_id, TRUE, $entity->id());
        }
      }
    }
  }
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function delivery_entity_bundle_info_alter(&$bundles) {
  // Make sure moderation states are never translatable.
  $bundles['content_moderation_state']['content_moderation_state']['translatable'] = FALSE;
}

/**
 * Implements hook_entity_base_field_info_alter().
 */
function delivery_entity_base_field_info_alter(&$fields, EntityTypeInterface $entity_type) {
  if (isset($fields['moderation_state'])) {
    $fields['moderation_state']->setTranslatable(FALSE);
  }

  if (isset($fields['status'])) {
    $fields['status']->setTranslatable(FALSE);
  }
}
